Day 4: 环境搭建、xdp 程序基本结构、bpf map
===========================================

搭建开发环境
---------------

主要的依赖就是 libbpf、llvm，clang、libelf。llvm+clang 将 xdp c 程序编译为 bpf，存储在 ELF obj 文件中。libbpf 用来 load bpf 程序入内核并将 bpf 程序 attach 到内核的各种 hook 中去。

.. code-block:: console

    $ yum install clang llvm elfutils-libelf-devel libbpf bpftool

详细可以参见（centos 的参见其中的 fedora 部分即可）：
https://github.com/xdp-project/xdp-tutorial/blob/master/setup_dependencies.org#dependencies

第一个 xdp 程序
------------------

一个 xdp 程序一般包含两个部分：

1. control plane 一个用户空间程序，一般以 _user.c 结尾，用来将 xdp bpf 程序加载从 elf 文件中加载入内核并且后续可以通过 bpf map 和其交互。
2. data plane 加载入内核的 bpf 程序，这个一般以 _kern.c 结尾，使用 clang 和 llvm 编译为 bpf。

以 https://github.com/xdp-project/xdp-tutorial/tree/master/basic01-xdp-pass 为例（就是一个啥也不干，直接将包交给内核去处理的程序）。

data plane 的程序大致如下：

.. code-block:: console

    $ cat xdp_pass_kern.c
    ...
    SEC ("xdp")
    int  xdp_prog_simple (struct xdp_md *ctx)
    {
        return XDP_PASS;
    }
    ...

将其编译为 obj 文件：

.. code-block:: console

    $ clang -S \
        -target bpf \
        -D __BPF_TRACING__ \
        -I../libbpf/src//build/usr/include/-I../headers/ \
        -Wall \
        -Wno-unused-value \
        -Wno-pointer-sign \
        -Wno-compare-distinct-pointer-types \
        -Werror \
        -O2 -emit-llvm -c -g -o xdp_pass_kern.ll xdp_pass_kern.c
    $ llc -march=bpf -filetype=obj -o xdp_pass_kern.o xdp_pass_kern.ll

control plane xdp_pass_user.c 的代码比较长，但核心代码如下：

.. code-block:: c

    int prog_fd = -1;
    struct bpf_object *obj;
    bpf_prog_load ("xdp_pass_kern.o", BPF_PROG_TYPE_XDP, &obj, &prog_fd);
    bpf_set_link_xdp_fd (ifindex, prog_fd, xdp_flags);

其中，ifindex 是要加载的网络接口的 index，这段代码主要就是调用 bpf_prog_load 加载 obj 文件中的 bpf 代码进内核，然后调用 bpf_set_link_xdp_fd 将这段代码挂载到网络接口的 hook 中去。

编译：

.. code-block:: console

    $ gcc -Wall -I../libbpf/src//build/usr/include/-g -I../headers/-L../libbpf/src/-o xdp_pass_user ../common//common_params.o \
    xdp_pass_user.c -l:libbpf.a -lelf

执行：

.. code-block:: console

    $ ./xdp_pass_user -d eth1  --skb-mode
    Success: Loading XDP prog name:xdp_prog_simple (id:24) on device:eth1 (ifindex:3)

查看：

.. code-block:: console

    $ ip link list dev eth1
    3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdpgeneric qdisc fq_codel state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:82:92:cd brd ff:ff:ff:ff:ff:ff
        prog/xdp id 24 tag 3b185187f1855c4c jited

最后一行可以看到 xdp 程序被加载入网络接口的 hook 中了。

xdp 代码加载模式
-----------------

xdp 代码有好几种加载的模式：skb/driver/hardware，性能上 skb < driver < hardware，但 driver 和 hardware 需要驱动和硬件的支持。

https://stackoverflow.com/questions/57171394/with-attach-xdp-does-flags-control-the-mode/57173029#57173029

查看网络接口的 driver

.. code-block:: console

    # ethtool -i eth1
    driver: e1000
    version: 7.3.21-k8-NAPI
    firmware-version:
    expansion-rom-version:
    bus-info: 0000:00:08.0
    supports-statistics: yes
    supports-test: yes
    supports-eeprom-access: yes
    supports-register-dump: yes
    supports-priv-flags: no

目前支持 xdp driver 的 driver list：

https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md#xdp

BPF Map 用户态程序和内核 bpf 的交互
-----------------------------------

这个应该可以用来存储 forwading table。

定义（在 _kernel.c 中定义一个全局变量）：

.. code-block:: c

    struct bpf_map_def SEC ("maps") xdp_stats_map = {
        .type        = BPF_MAP_TYPE_ARRAY,
        .key_size    = sizeof (__u32),
        .value_size  = sizeof (struct datarec),
        .max_entries = XDP_ACTION_MAX,
    };

在 bpf 程序中，直接调用 bpf 接口就可以操作 map 了：

.. code-block:: c

    rec = bpf_map_lookup_elem (&xdp_stats_map, &key);
    lock_xadd (&rec->rx_packets, 1);

.. _bpf-map:

在用户态的程序中操作 map 需要先通过 map 名获取 map 的 fd，然后再通过 map fd 操作：

.. code-block:: c

    map =  bpf_object__find_map_by_name (bpf_obj, "xdp_stats_map");
    map_fd = bpf_map__fd (map);
    map_get_value_array (map_fd , key, &value)

bpf map 有很多种类型：https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps_types.html

网络原始数据包在哪？
-----------------------

xdp bpf 程序的回调函数的参数是一个 xdp_md\* 指针，这个数据结构定义如下：

.. code-block:: c

    struct xdp_md {
        __u32 data;
        __u32 data_end;
        __u32 data_meta;
        __u32 ingress_ifindex; //rxq->dev->ifindex
        __u32 rx_queue_index;  //rxq->queue_index
    };

data 和 data_end 之间就是收到的网络原始数据包的内容：

.. code-block:: c

    struct ethhdr *eth = data;
    assert ((void*) eth + sizeof (*eth) <= data_end);

Python BPF 操作库
----------------------

iovisor/bcc 封装了一个 python BPF 操作库 https://github.com/iovisor/bcc