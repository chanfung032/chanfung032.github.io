
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>#220915 UDP 隧道 &#8212; Feng&#39;s blog 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/custom.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="#220901 socket 和 sock" href="220905-socket.html" />
    <link rel="prev" title="#220919 配置" href="220919-devconf.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="udp-sui-dao">
<h1>#220915 UDP 隧道<a class="headerlink" href="#udp-sui-dao" title="Permalink to this headline">¶</a></h1>
<section id="shou-bao-chu-li-lu-jing">
<h2>收包处理路径<a class="headerlink" href="#shou-bao-chu-li-lu-jing" title="Permalink to this headline">¶</a></h2>
<p>以 fou 隧道为例，隧道创建的时候，会创建一个 udp socket，并设置其对应的 <code class="docutils literal notranslate"><span class="pre">udp_sock.encap_rcv</span></code> 为 <code class="docutils literal notranslate"><span class="pre">fou_udp_recv</span></code> 函数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fou_create</span><span class="p">(</span><span class="n">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">struct</span> <span class="n">fou_cfg</span> <span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="n">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">sockp</span><span class="p">)</span>
<span class="o">|-</span> <span class="n">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">NULL</span>
<span class="o">|-</span> <span class="n">udp_sock_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">udp_config</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">)</span>
<span class="o">|</span>  <span class="o">...</span>
<span class="o">|-</span> <span class="n">struct</span> <span class="n">udp_tunnel_sock_cfg</span> <span class="n">tunnel_cfg</span>
<span class="o">|-</span> <span class="n">tunnel_cfg</span><span class="o">.</span><span class="n">encap_rcv</span> <span class="o">=</span> <span class="n">fou_udp_recv</span>
<span class="o">|</span>  <span class="o">...</span>
<span class="o">|-</span> <span class="n">setup_udp_tunnel_sock</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tunnel_cfg</span><span class="p">)</span>
   <span class="o">|-</span> <span class="n">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span>
   <span class="o">|</span>  <span class="o">...</span>
   <span class="o">|-</span> <span class="n">udp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">encap_rcv</span> <span class="o">=</span> <span class="n">tunnel_cfg</span><span class="o">-&gt;</span><span class="n">encap_rcv</span>
   <span class="o">|</span>  <span class="o">...</span>
</pre></div>
</div>
<p>通过 netstat 可以看到这个 socket。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ip fou add port <span class="m">19523</span>
<span class="gp"># </span>netstat -nlu
<span class="go">Active Internet connections (only servers)</span>
<span class="go">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span>
<span class="go">...</span>
<span class="go">udp        0      0 0.0.0.0:19523           0.0.0.0:*</span>
<span class="go">...</span>
</pre></div>
</div>
<p>然后 udp_rcv 函数中会判断找到的 udp socket 的 <code class="docutils literal notranslate"><span class="pre">encap_rcv</span></code> 是不是为空，为空，走正常路径，如果不为空，则走隧道路径。</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  udp_rcv
  |- __udp4_lib_rcv
     |- sk = __udp4_lib_lookup_skb
     |- udp_unicast_rcv_skb(sk, skb)
        |- udp_queue_rcv_skb
           |- udp_queue_rcv_one_skb
<span class="gi">+             |- struct udp_sock *up = udp_sk(sk)</span>
<span class="gi">+             |- if up-&gt;encap_type</span>
<span class="gi">+             |     ret = up-&gt;encap_rcv(sk, skb)</span>
<span class="gi">+             |     if ret &lt;= 0</span>
<span class="gi">+             |        return -ret</span>
              |- __udp_queue_rcv_skb
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">encap_rcv</span></code> 回调函数的返回值有以下三种情况：</p>
<ol class="arabic simple">
<li><p>等于 0，这个包被隧道层处理函数丢弃掉了，直接返回即可。</p></li>
<li><p>大于 0，内层包的协议也是 UDP，继续往下执行。</p></li>
<li><p>小于 0，这种内层封包的协议不是 UDP，需要回溯到网络层，在 <code class="docutils literal notranslate"><span class="pre">ip_local_deliver_finish</span></code> 中重新投送。</p></li>
</ol>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  ip_local_deliver_finish
  |- ip_protocol_deliver_rcu(skb, ip_hdr(skb)-&gt;protocol)
<span class="gi">+    |resubmit:</span>
     |- ipprot = inet_protos[protocol]
     |- ret = ipprot-&gt;handler/tcp_v4_rcv/udp_rcv/tunnel4_rcv/tunnel64_rcv(skb)
<span class="gi">+    |- if ret &lt; 0</span>
<span class="gi">+         protocol = -ret</span>
<span class="gi">+         goto resubmit</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">inet_protos</span></code> 里除了普通传输层协议的各种处理函数，还有各种隧道协议注册的处理函数。</p>
</section>
<section id="jie-bao">
<h2>解包<a class="headerlink" href="#jie-bao" title="Permalink to this headline">¶</a></h2>
<p>首先在 fou 模块的设置的 <code class="docutils literal notranslate"><span class="pre">encap_rcv</span></code> 回调函数 <code class="docutils literal notranslate"><span class="pre">fou_udp_recv</span></code> 中。剥除外层的 UDP 头，将传输层指向内层 IP/IPv6 包的开头。然后回调函数返回 <code class="docutils literal notranslate"><span class="pre">-IPPROTO_IPIP</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">-IPPROTO_IPV6</span></code> 来调用通用的解包函数来接包。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fou_recv_pull</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">fou</span><span class="w"> </span><span class="o">*</span><span class="n">fou</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// 从外层 IP 包中减去 UDP 头的大小</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fou</span><span class="o">-&gt;</span><span class="n">family</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htons</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">htons</span><span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 剥除 UDP 协议头</span>
<span class="w">   </span><span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="c1">// 更新外层 IP 包的 checksum</span>
<span class="w">   </span><span class="n">skb_postpull_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="c1">// 更新传输层指向内层 IP 包的开头</span>
<span class="w">   </span><span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">iptunnel_pull_offloads</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fou_udp_recv</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">struct</span> <span class="nc">fou</span><span class="w"> </span><span class="o">*</span><span class="n">fou</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fou_from_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">fou</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fou_recv_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">fou</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">udphdr</span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">drop</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// 返回 fou 隧道的协议，可能是 IPPROTO_IPIP、IPPROTO_IPV6</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">fou</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span><span class="w"></span>

<span class="nl">drop</span><span class="p">:</span><span class="w"></span>
<span class="w">   </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果是一个 IPv6 in IPv4 的包。那就是返回 <code class="docutils literal notranslate"><span class="pre">-IPPROTO_IPV6</span></code>，回到 IP 层 resubmit 后就到了 <code class="docutils literal notranslate"><span class="pre">tunnel64_rcv</span></code> 这个回调函数中。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">tunnel64_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">struct</span> <span class="nc">xfrm_tunnel</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ipv6hdr</span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">drop</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">for_each_tunnel_rcu</span><span class="p">(</span><span class="n">tunnel64_handlers</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span><span class="w"></span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">icmp_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">ICMP_DEST_UNREACH</span><span class="p">,</span><span class="w"> </span><span class="n">ICMP_PORT_UNREACH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="nl">drop</span><span class="p">:</span><span class="w"></span>
<span class="w">   </span><span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>sit 模块在初始化的时候会调用 <code class="docutils literal notranslate"><span class="pre">xfrm4_tunnel_register</span></code> 注册 <code class="docutils literal notranslate"><span class="pre">IPPROTO_IPV6</span></code> 的处理函数 <code class="docutils literal notranslate"><span class="pre">ipip6_rcv</span></code> 。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">xfrm_tunnel</span><span class="w"> </span><span class="n">sit_handler</span><span class="w"> </span><span class="n">__read_mostly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">.</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w">        </span><span class="n">ipip6_rcv</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="p">.</span><span class="n">err_handler</span><span class="w"> </span><span class="o">=</span><span class="w">    </span><span class="n">ipip6_err</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w">       </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">sit_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xfrm4_tunnel_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sit_handler</span><span class="p">,</span><span class="w"> </span><span class="n">AF_INET6</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>tunnel64_rcv 中会遍历所有注册的处理 IPv6 in IPv4 的包的处理函数并调用。就会调用到 <code class="docutils literal notranslate"><span class="pre">ipip6_rcv</span></code> 。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ipip6_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// 这个是外层 IP 头</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">iphdr</span><span class="w"> </span><span class="o">*</span><span class="n">iph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">tunnel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ipip6_tunnel_lookup</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span><span class="w"> </span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span><span class="w"> </span><span class="n">sifindex</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tunnel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">...</span><span class="w"></span>

<span class="w">      </span><span class="c1">// 让 iphdr 指针指向内层 IPv6 头</span>
<span class="w">      </span><span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="p">...</span><span class="w"></span>

<span class="w">      </span><span class="c1">// 重新提交包到协议栈网络层</span>
<span class="w">      </span><span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="cm">/* no tunnel matched,  let upstream know, ipsec may handle it */</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="gro-mei-qi-zuo-yong">
<h2>GRO 没起作用？<a class="headerlink" href="#gro-mei-qi-zuo-yong" title="Permalink to this headline">¶</a></h2>
<p>5.13 前内核的 UDP 隧道 有个 GRO 的 BUG，UDP 包的 checksum 为 0 的时候， <code class="docutils literal notranslate"><span class="pre">udp_gro_receive</span></code> 函数中会误认为不满足合并包的条件而提前终止，所以 GUE 这一类的 UDP 隧道协议虽然早就实现了协议对应的 <code class="docutils literal notranslate"><span class="pre">gro_receive</span></code>、 <code class="docutils literal notranslate"><span class="pre">gro_complete</span></code> 处理函数，但是因为 GRO 在 UDP 层提前终止了，实际还是没有起作用。</p>
<p>详细见：<a class="reference external" href="https://github.com/torvalds/linux/commit/89e5c58fc1e2857ccdaae506fb8bc5fed57ee063">https://github.com/torvalds/linux/commit/89e5c58fc1e2857ccdaae506fb8bc5fed57ee063</a></p>
<p>虽然物理网卡这一层的 GRO 没有生效，但是对于 <code class="docutils literal notranslate"><span class="pre">IPPROTO_IPIP</span></code> 类型的隧道协议包，在解包之后 redirect 到对应的逻辑网卡时还有一次 GRO 机会。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ipip_rcv
|- ipip_tunnel_rcv(skb, IPPROTO_IPIP)
   |- ip_tunnel_rcv
      |- gro_cells_receive
         |- if (!gcells-&gt;cells || skb_cloned(skb) || !(dev-&gt;features &amp; NETIF_F_GRO))
         |    netif_rx(skb)
         |    return
         |- __skb_queue_tail(&amp;cell-&gt;napi_skbs, skb)
         |- napi_schedule(&amp;cell-&gt;napi)
</pre></div>
</div>
<p>这个看到的现象就是 tcpdump 看物理网卡上收到的 UDP 隧道协议包都是大小 1500 以下的小包，但是在隧道对应的逻辑网卡上抓包看到的内层包能看到 1500 以上的大包。</p>
<p>IPPROTO_IPV6 协议没有，详细可以看上面 <code class="docutils literal notranslate"><span class="pre">ipip6_rcv</span></code> 函数， <code class="docutils literal notranslate"><span class="pre">ipip6_rcv</span></code> 没有做第二次 GRO。</p>
<p>内核 UDP 性能相关的一些优化和版本：<a class="reference external" href="https://developers.redhat.com/articles/2021/11/05/improve-udp-performance-rhel-85">https://developers.redhat.com/articles/2021/11/05/improve-udp-performance-rhel-85</a></p>
</section>
<section id="tso-gso">
<h2>TSO/GSO<a class="headerlink" href="#tso-gso" title="Permalink to this headline">¶</a></h2>
<p>veth 测隧道 TSO 没有问题，但虚拟机 virtio 驱动下 TSO 似乎都有问题？（待进一步测试），在 veth 上测，GRO/GSO 关闭开启对性能影响不是特别大，但是 TSO 对性能影响巨大。</p>
</section>
<section id="ge-zhong-sui-dao-lei-xing">
<h2>各种隧道类型<a class="headerlink" href="#ge-zhong-sui-dao-lei-xing" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://developers.redhat.com/blog/2019/05/17/an-introduction-to-linux-virtual-interfaces-tunnels">https://developers.redhat.com/blog/2019/05/17/an-introduction-to-linux-virtual-interfaces-tunnels</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">#220915 UDP 隧道</a><ul>
<li><a class="reference internal" href="#shou-bao-chu-li-lu-jing">收包处理路径</a></li>
<li><a class="reference internal" href="#jie-bao">解包</a></li>
<li><a class="reference internal" href="#gro-mei-qi-zuo-yong">GRO 没起作用？</a></li>
<li><a class="reference internal" href="#tso-gso">TSO/GSO</a></li>
<li><a class="reference internal" href="#ge-zhong-sui-dao-lei-xing">各种隧道类型</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/network/220915-udp-tunnel.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="https://cn.bing.com/search" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>
$('#searchbox').show(0);
document.getElementsByClassName('search')[0].addEventListener('submit', function(event) {
  event.preventDefault();
  var form = event.target;
  var input = form.querySelector('input[name="q"]');
  var value = input.value;
  var q = 'ensearch=1&q=site%3Achanfung032.github.io++' + value;
  var url = form.action + '?' + q;
  window.location.href = url;
});
</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, chanfung032.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/network/220915-udp-tunnel.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>