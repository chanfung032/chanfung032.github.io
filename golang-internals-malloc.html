
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Go 语言实现——内存管理 &#8212; Feng&#39;s blog 1.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Go 语言实现——网络 IO" href="golang-internals-io.html" />
    <link rel="prev" title="跳表 Skiplist" href="skiplist.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="go-yu-yan-shi-xian-nei-cun-guan-li">
<h1>Go 语言实现——内存管理<a class="headerlink" href="#go-yu-yan-shi-xian-nei-cun-guan-li" title="Permalink to this headline">¶</a></h1>
<div class="section" id="gai-shu">
<h2>概述<a class="headerlink" href="#gai-shu" title="Permalink to this headline">¶</a></h2>
<p>Go 语言的堆内存分配是基于 <a class="reference external" href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> 的模型实现的，是一个带有 thread cache 的分配器。</p>
<p>分配器一开始向操作系统申请一大片地址空间用于内存分配，分配器的分配单位是 page（8kb）。</p>
<ul class="simple">
<li>对于大于 32kb 的 object 分配器直接分配连续的 page。</li>
<li>小于 32kb 的 small object 的分配稍微复杂一点。首先，分配器从 1~32k 定义了大约 70 个大小固定的 object class，分配器分配连续的 page 给这些 object class 去使用，然后要分配 small object 的时候，按其 object 大小向上寻找一个最接近其大小的 object class，从这个 object class 的 page 中切一块分配给这个 object。object class 中的 page 用完了再分配新的 page。</li>
</ul>
<p>分配器中分配出去的连续 page 叫做 span ，线程会为每个 object class 缓存一个 span 用于本线程的 small object 分配，这样大部分情况下 small object 的分配就不用加全局锁了。</p>
</div>
<div class="section" id="zhu-yao-shu-ju-jie-gou">
<h2>主要数据结构<a class="headerlink" href="#zhu-yao-shu-ju-jie-gou" title="Permalink to this headline">¶</a></h2>
<p>和分配器相关的主要是 mheap、mcentral、mspan、mcache 这四个结构体。</p>
<ul class="simple">
<li>mheap 分配器相关的结构体。</li>
<li>mcentral 管理分配给每个 object class 的所有 span。</li>
<li>mspan 管理分配出去的 span 。</li>
<li>mcache 管理每个线程的 span cache 的结构体。</li>
</ul>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 所有已分配的 span</span>
    <span class="nx">allspans</span> <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span>
    <span class="c1">// arena 中已使用的 page 到对应的 *mspan 的映射表，1 个 page 对应一个</span>
    <span class="nx">spans</span> <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span>

    <span class="c1">// gc 标志用（暂时忽略）</span>
    <span class="nx">bitmap</span>        <span class="kt">uintptr</span>
    <span class="nx">bitmap_mapped</span> <span class="kt">uintptr</span>

    <span class="c1">// arena 是真正用来分配 span 的内存空间</span>
    <span class="nx">arena_start</span> <span class="kt">uintptr</span>
    <span class="nx">arena_used</span>  <span class="kt">uintptr</span>
    <span class="nx">arena_alloc</span> <span class="kt">uintptr</span>
    <span class="nx">arena_end</span>   <span class="kt">uintptr</span>
    <span class="nx">arena_reserved</span> <span class="kt">bool</span>

    <span class="c1">// 全局存放每个 object class 对应的 span 的地方</span>
    <span class="nx">central</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">mcentral</span> <span class="nx">mcentral</span>
    <span class="p">}</span>

    <span class="c1">// 空闲的 span 会被加入到下面几个结构里。</span>
    <span class="c1">// free[5] 里包含所有空闲的 npages = 5 的 mspan</span>
    <span class="c1">// npages &gt;= _MaxMHeapList 的存在 freelarge 里</span>
    <span class="nx">free</span>      <span class="p">[</span><span class="nx">_MaxMHeapList</span><span class="p">]</span><span class="nx">mSpanList</span>
    <span class="nx">freelarge</span> <span class="nx">mTreap</span>
    <span class="c1">// 在使用中的 span</span>
    <span class="nx">busy</span>      <span class="p">[</span><span class="nx">_MaxMHeapList</span><span class="p">]</span><span class="nx">mSpanList</span>
    <span class="nx">busylarge</span> <span class="nx">mSpanList</span>

    <span class="c1">// span 结构体、mcache 结构体、treap 结构体分配器</span>
    <span class="nx">spanalloc</span>             <span class="nx">fixalloc</span>
    <span class="nx">cachealloc</span>            <span class="nx">fixalloc</span>
    <span class="nx">treapalloc</span>            <span class="nx">fixalloc</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">mheap_</span> <span class="nx">mheap</span>

<span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">spanclass</span> <span class="nx">spanClass</span>
    <span class="nx">nonempty</span>  <span class="nx">mSpanList</span>   <span class="c1">// 没有空 slot 的 span 列表</span>
    <span class="nx">empty</span>     <span class="nx">mSpanList</span>   <span class="c1">// 还有空 slot 的 span 列表</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>
    <span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>

    <span class="c1">// span 管理的 page 的开始地址和 page 个数</span>
    <span class="nx">startAddr</span> <span class="kt">uintptr</span>
    <span class="nx">npages</span>    <span class="kt">uintptr</span>

    <span class="c1">// 管理的 page 会被分成 nelems 个 elemsize 大小的 slot 用来存对象，</span>
    <span class="c1">// allocBits 是 bitmap，每个 slot 在里面对应一个 bit ，标示是否为空。</span>
    <span class="c1">// freeindex = 上次分配的对象的 slot 的 index + 1</span>
    <span class="c1">// 每次分配从 freeindex 开始往后找空闲位置，freeindex == nelems 表示这个 span 存满了</span>
    <span class="nx">freeindex</span> <span class="kt">uintptr</span>
    <span class="nx">nelems</span> <span class="kt">uintptr</span>
    <span class="nx">elemsize</span>    <span class="kt">uintptr</span>
    <span class="c1">// allocBits 是 alloBits 从 freeindex 这个 slot 开始的一段缓存，freeindex 对应最低位 bit</span>
    <span class="nx">allocCache</span> <span class="kt">uint64</span>
    <span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>

    <span class="c1">// 已分配的 slot 数目</span>
    <span class="nx">allocCount</span>  <span class="kt">uint16</span>
    <span class="c1">// sizeclass&lt;&lt;1 | noscan</span>
    <span class="nx">spanclass</span>   <span class="nx">spanClass</span>
    <span class="c1">// 是否被 mcache 使用</span>
    <span class="nx">incache</span>     <span class="kt">bool</span>
    <span class="nx">state</span>       <span class="nx">mSpanState</span> <span class="c1">// mspaninuse etc</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Tiny allocator</span>
    <span class="nx">tiny</span>             <span class="kt">uintptr</span>
    <span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>

    <span class="c1">// span 缓存</span>
    <span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="chu-shi-hua">
<h2>初始化<a class="headerlink" href="#chu-shi-hua" title="Permalink to this headline">¶</a></h2>
<p>在 Go 运行环境初始化的过程中，会调用 mallocinit() 函数初始化堆内存分配器，mallocinit() 会向操作系统申请如下的一段虚拟地址空间：</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="31%" />
<col width="34%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>spans 512M</td>
<td>bitmap 16G</td>
<td>arena 512G</td>
</tr>
</tbody>
</table>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">spans</span><span class="p">.</span><span class="nx">array</span> <span class="p">=</span> <span class="nx">spans</span>
<span class="nx">mheap_</span><span class="p">.</span><span class="nx">bitmap</span> <span class="p">=</span> <span class="nx">bitmap</span>
<span class="nx">mheap_</span><span class="p">.</span><span class="nx">arena_start</span> <span class="p">=</span> <span class="nx">arena</span>
</pre></div>
</div>
<p>这段地址空间中的 arena 就是最终分配 object 用的内存空间，前两个是分配器自用：</p>
<ul class="simple">
<li>spans 是 mheap_.spans 这个 slice 的底层 array 。</li>
<li>bitmap 是给 gc 来标记对象用的（Go 的 object 里没有 object header，所以这个标记只能外放了）。</li>
</ul>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">mallocinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">pSize</span> <span class="kt">uintptr</span>
    <span class="kd">var</span> <span class="nx">reserved</span> <span class="kt">bool</span>

    <span class="c1">// _MaxMem = 申请的堆空间大小 - 1，64-bit 机器上为 512GB</span>
    <span class="c1">// _PageSize = 8k</span>
    <span class="c1">// 计算 span 和 bitmap 的大小</span>
    <span class="kd">var</span> <span class="nx">spansSize</span> <span class="kt">uintptr</span> <span class="p">=</span> <span class="p">(</span><span class="nx">_MaxMem</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">_PageSize</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
    <span class="nx">spansSize</span> <span class="p">=</span> <span class="nx">round</span><span class="p">(</span><span class="nx">spansSize</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">bitmapSize</span> <span class="kt">uintptr</span> <span class="p">=</span> <span class="p">(</span><span class="nx">_MaxMem</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">bitmapSize</span> <span class="p">=</span> <span class="nx">round</span><span class="p">(</span><span class="nx">bitmapSize</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
        <span class="c1">// 计算 arena 的大小（也就是真正用来分配的 heap memory）</span>
        <span class="nx">arenaSize</span> <span class="o">:=</span> <span class="nx">round</span><span class="p">(</span><span class="nx">_MaxMem</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span>
        <span class="nx">pSize</span> <span class="p">=</span> <span class="nx">bitmapSize</span> <span class="o">+</span> <span class="nx">spansSize</span> <span class="o">+</span> <span class="nx">arenaSize</span> <span class="o">+</span> <span class="nx">_PageSize</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mh">0x7f</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">{</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="nx">p</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">40</span> <span class="p">|</span> <span class="nx">uintptrMask</span><span class="o">&amp;</span><span class="p">(</span><span class="mh">0x00c0</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// mmap(nil, pSize, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0)</span>
            <span class="c1">// 在 64-bit 机器上这里并不会实际分配内存，只是检查了 mmap 是否 ok，分配是 lazy 的，</span>
            <span class="nx">p</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sysReserve</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">pSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">reserved</span><span class="p">))</span>
            <span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">p1</span> <span class="o">:=</span> <span class="nx">round</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">_PageSize</span><span class="p">)</span>
    <span class="nx">pSize</span> <span class="o">-=</span> <span class="nx">p1</span> <span class="o">-</span> <span class="nx">p</span>
    <span class="nx">spansStart</span> <span class="o">:=</span> <span class="nx">p1</span>

    <span class="nx">p1</span> <span class="o">+=</span> <span class="nx">spansSize</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">bitmap</span> <span class="p">=</span> <span class="nx">p1</span> <span class="o">+</span> <span class="nx">bitmapSize</span>

    <span class="nx">p1</span> <span class="o">+=</span> <span class="nx">bitmapSize</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arena_start</span> <span class="p">=</span> <span class="nx">p1</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arena_end</span> <span class="p">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="nx">pSize</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arena_used</span> <span class="p">=</span> <span class="nx">p1</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arena_alloc</span> <span class="p">=</span> <span class="nx">p1</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arena_reserved</span> <span class="p">=</span> <span class="nx">reserved</span>

    <span class="c1">// 初始化 mheap</span>
    <span class="c1">// 这个里面会将 spansStart 赋给 mheap_.spans.array</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">spansStart</span><span class="p">,</span> <span class="nx">spansSize</span><span class="p">)</span>

    <span class="c1">// 给第一个虚拟线程初始化 mcache 结构</span>
    <span class="c1">// 后续会在 procresize() 中被赋给第一个创建的虚拟线程 p.mcache</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nx">getg</span><span class="p">()</span>
    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nx">allocmcache</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="fen-pei">
<h2>分配<a class="headerlink" href="#fen-pei" title="Permalink to this headline">¶</a></h2>
<p>堆内存分配器的入口是 newobject，从其函数中能看到其对 small 和 large object 的不同处理。</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">newobject</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="c1">// 空结构体 struct{}，直接返回 &amp;zerobase 的地址</span>
    <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 获取运行 goroutine 线程的 mcache 结构体指针</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">gomcache</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
    <span class="c1">// 好吧，概述里说的按照 object size 大小分成 70 多个 object</span>
    <span class="c1">// 并不准确，其实是 70 * 2，object 会按 object 里是否包含指针</span>
    <span class="c1">// 再分成两类，真正的 object class = object size &lt;&lt; 1 | noscan</span>
    <span class="nx">noscan</span> <span class="o">:=</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
            <span class="c1">// 不包含指针并且 size &lt; 16 的 object 为 tiny object，使用 tiny</span>
            <span class="c1">// allocator 来分配。</span>
            <span class="c1">// tiny allocator 每次向 mcache 申请一块 16 个字节大小的内存，每次</span>
            <span class="c1">// 申请内存的 tiny object 从这块内存上割一块，不够了再新申请。</span>
            <span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
            <span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
                <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
                <span class="k">return</span> <span class="nx">x</span>
            <span class="p">}</span>
            <span class="nx">span</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
            <span class="nx">v</span> <span class="o">:=</span> <span class="nx">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">v</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
            <span class="c1">// 新的 tiny object 需要将内存清零</span>
            <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
                <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 不是 tiny object 并且小于 32k 的 small object</span>
            <span class="kd">var</span> <span class="nx">sizeclass</span> <span class="kt">uint8</span>
            <span class="c1">// 计算 object 的 sizeclass</span>
            <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
                <span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class8</span><span class="p">[(</span><span class="nx">size</span><span class="o">+</span><span class="nx">smallSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">smallSizeDiv</span><span class="p">]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class128</span><span class="p">[(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="o">+</span><span class="nx">largeSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">largeSizeDiv</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="c1">// 根据 sizeclass 获取实际分配的内存大小</span>
            <span class="nx">size</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
            <span class="c1">// spc = sizeclass&lt;&lt;1 | noscan</span>
            <span class="nx">spc</span> <span class="o">:=</span> <span class="nx">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
            <span class="nx">span</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
            <span class="nx">v</span> <span class="o">:=</span> <span class="nx">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 大于 32 k</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
        <span class="nx">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="p">=</span> <span class="nx">largeAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">base</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码中 nextFreeFast 会尝试根据 span.allocCache 直接找到下一个空闲 slot 用来分配，如果没找到再调用 c.nextFree(spc) 根据 span.alloBits 来找到下一个空闲 slot 并且重新装填 span.allocCache。mcache 在初始化的时候所有的 object class 缓存的 span 都是 emptymspan，一个没有任何 page 的空 span，在 span 没有空闲 slot 的情况下，c.nextFree(spc) 会调用 c.refill() 向 mheap_.central 重新申请一个新的可用 span。</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nx">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 将当前缓存的 span 还给 mcentral。</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">incache</span> <span class="p">=</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="c1">// 从 mcentral 中获取一个新的可用 span。</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nx">cacheSpan</span><span class="p">()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nx">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
<span class="nx">retry</span><span class="p">:</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
    <span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
        <span class="c1">// 尝试从 c.nonempty 分配，初始为空，跳过</span>
        <span class="c1">// 成功 goto havespan</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
        <span class="c1">// 尝试从 c.empty 分配，初始为空，跳过</span>
        <span class="c1">// 成功 goto havespan</span>
    <span class="p">}</span>

    <span class="c1">// 如果上面分配失败，那么申请新的 span</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">grow</span><span class="p">()</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

<span class="nx">havespan</span><span class="p">:</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">incache</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果 mcentral 中没有可用的 span，mcentral 会调用 mheap.alloc() 申请一个新的 span。</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nx">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
    <span class="c1">// 根据 span 的 sizeclass 确定要分配多少 page。</span>
    <span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nx">sizeclass</span><span class="p">()])</span>
    <span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nx">sizeclass</span><span class="p">()])</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span>

    <span class="c1">// 从 arena 中分配一个新的 npages span</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">base</span><span class="p">()</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>

    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<p>mheap 分配新的 span 的逻辑如下：</p>
<ol class="arabic simple">
<li>检查 mheap.free 中有没有空闲 span, 有的话返回。</li>
<li>检查 mheap.freelarge 中有没有空闲 span，有的话裁剪返回。</li>
<li>从 mheap.arena 中再新分配一个至少 64 kb 的 span 并释放到 mheap.freelarge 中，返回 2 继续执行。</li>
</ol>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nx">alloc</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
    <span class="nx">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">alloc_m</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="nx">spanclass</span><span class="p">,</span> <span class="nx">large</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nx">alloc_m</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nx">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">list</span> <span class="o">*</span><span class="nx">mSpanList</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>

    <span class="c1">// 在 mheap.free 里找找有没有合适的</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">npage</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">free</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">list</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">free</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="p">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">first</span>
            <span class="nx">list</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
            <span class="k">goto</span> <span class="nx">HaveSpan</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 在 mheap.freelarge 里找找有没有合适的</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allocLarge</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 找不到的话从 arena 中新分配 npage 并创建一个新的 span</span>
        <span class="c1">// 新 span 至少有 64kb ，创建后会被 free 到 h.freelarge 里。</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nx">grow</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allocLarge</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nx">HaveSpan</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&gt;</span> <span class="nx">npage</span> <span class="p">{</span>
        <span class="c1">// 将多余的 page 裁剪后放入 free span 中</span>
        <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mspan</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nx">alloc</span><span class="p">())</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">base</span><span class="p">()</span><span class="o">+</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">-</span><span class="nx">npage</span><span class="p">)</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">=</span> <span class="nx">npage</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">base</span><span class="p">()</span> <span class="o">-</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
        <span class="p">}</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="o">+</span><span class="nx">t</span><span class="p">.</span><span class="nx">npages</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanManual</span> <span class="c1">// prevent coalescing with s</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">freeSpanLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">base</span><span class="p">()</span> <span class="o">-</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">npage</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="o">+</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="hui-shou">
<h2>回收<a class="headerlink" href="#hui-shou" title="Permalink to this headline">¶</a></h2>
<p>当一个 span 中所有的对象被释放时，这个 span 会被回收（对象的释放由 gc 来完成，这里暂且先跳过），回收的 span 会被加入到 mheap.free 和 mheap.freelarge 中，供后续新的 span 申请使用。</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nx">freeSpan</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">acct</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nx">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">acctinuse</span><span class="p">,</span> <span class="nx">acctidle</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">unusedsince</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">_MSpanFree</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">inList</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 将 span 从 busyList 中删除</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">busyList</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nx">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 如果要 free 的 span 前面的 span 也是 free 的，合并</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">base</span><span class="p">()</span> <span class="o">-</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
    <span class="k">if</span> <span class="nx">p</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">before</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">before</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">before</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">_MSpanFree</span> <span class="p">{</span>
            <span class="c1">// Now adjust s.</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">startAddr</span> <span class="p">=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">startAddr</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">+=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">npages</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">npreleased</span> <span class="p">=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">npreleased</span> <span class="c1">// absorb released pages</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">|=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">needzero</span>
            <span class="nx">p</span> <span class="o">-=</span> <span class="nx">before</span><span class="p">.</span><span class="nx">npages</span>
            <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
            <span class="c1">// The size is potentially changing so the treap needs to delete adjacent nodes and</span>
            <span class="c1">// insert back as a combined node.</span>
            <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">isLargeSpan</span><span class="p">(</span><span class="nx">before</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">h</span><span class="p">.</span><span class="nx">freelarge</span><span class="p">.</span><span class="nx">removeSpan</span><span class="p">(</span><span class="nx">before</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">h</span><span class="p">.</span><span class="nx">freeList</span><span class="p">(</span><span class="nx">before</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nx">remove</span><span class="p">(</span><span class="nx">before</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nx">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">before</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 如果要 free 的 span 后面的 span 也是 free 的，合并</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">after</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">after</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">after</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">_MSpanFree</span> <span class="p">{</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">+=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">npages</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">npreleased</span> <span class="o">+=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">npreleased</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">|=</span> <span class="nx">after</span><span class="p">.</span><span class="nx">needzero</span>
            <span class="nx">h</span><span class="p">.</span><span class="nx">spans</span><span class="p">[</span><span class="nx">p</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
            <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">isLargeSpan</span><span class="p">(</span><span class="nx">after</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">h</span><span class="p">.</span><span class="nx">freelarge</span><span class="p">.</span><span class="nx">removeSpan</span><span class="p">(</span><span class="nx">after</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">h</span><span class="p">.</span><span class="nx">freeList</span><span class="p">(</span><span class="nx">after</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nx">remove</span><span class="p">(</span><span class="nx">after</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nx">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">after</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 将空闲的 span 插入 h.freelarge 或者 h.free 中。</span>
    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">isLargeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">freelarge</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">freeList</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">).</span><span class="nx">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最后 sysmon 每隔一段时间会执行 mheap_.scavenge(）将长时间不用的 span 的内存通过 madvise(MADV_DONTNEED) “释放” 给操作系统。</p>
<blockquote>
<div>MADV_DONTNEED: Do not expect access in the near future. (For the time being, the application is finished with the given range, so the kernel can free resources associated with it.) Subsequent accesses of pages in this range will succeed, but will result either in reloading of the memory contents from the underlying mapped file (see mmap(2)) or zero-fill-on-demand pages for mappings without an underlying file.</div></blockquote>
</div>
<div class="section" id="fen-pei-qi-zi-yong-di-nei-cun-fen-pei">
<h2>分配器自用的内存分配<a class="headerlink" href="#fen-pei-qi-zi-yong-di-nei-cun-fen-pei" title="Permalink to this headline">¶</a></h2>
<p>分配器自用的一些结构体 mcache、mspan 等是通过 fixalloc 分配器来分配的。</p>
<blockquote>
<div>fixalloc is a SLAB-style allocator that allocates objects of a fixed
size. fixalloced objects can be freed, but this memory can only be
reused by the same fixalloc pool, so it can only be reused for
objects of the same type.</div></blockquote>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Go 语言实现——内存管理</a><ul>
<li><a class="reference internal" href="#gai-shu">概述</a></li>
<li><a class="reference internal" href="#zhu-yao-shu-ju-jie-gou">主要数据结构</a></li>
<li><a class="reference internal" href="#chu-shi-hua">初始化</a></li>
<li><a class="reference internal" href="#fen-pei">分配</a></li>
<li><a class="reference internal" href="#hui-shou">回收</a></li>
<li><a class="reference internal" href="#fen-pei-qi-zi-yong-di-nei-cun-fen-pei">分配器自用的内存分配</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="skiplist.html" title="previous chapter">跳表 Skiplist</a></li>
      <li>Next: <a href="golang-internals-io.html" title="next chapter">Go 语言实现——网络 IO</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/golang-internals-malloc.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, chanfung032.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/golang-internals-malloc.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>